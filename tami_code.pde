import geomerative.*;
import processing.pdf.*;
import java.util.Calendar;

RFont font;

String silentString = "S I L E N T";
color silentDotColor = #FA7272;
color silentCrossColor = #ED1111;

String listenString = "L I S T E N";
color listenDotColor = #009D8F;
color listenCrossColor = #CBFFD4;

int shapeSet = 0;
PShape dotShape, crossShape;
float targetX = 0; 
float targetY = 0;
PVector facePos;

void setup() {
  fullScreen();
  setupScreen(); // important for scaling the screen for the correct size
  setupTracking();// important for getting the face tracking information in dinFormat
  //myGraphic = new graphic();
  //setupString1();
    smooth();

  dotShape = loadShape("A_01.svg");
  crossShape = loadShape("A_02.svg");
  dotShape.disableStyle();
  crossShape.disableStyle();

  // allways initialize the library in setup
  RG.init(this);

  // load a truetype font
  font = new RFont("FreeSans.ttf", width/10, RFont.LEFT);
  
  RCommand.setSegmentLength(6);
  RCommand.setSegmentator(RCommand.UNIFORMLENGTH);
};

void draw() {
 
  background(240);
  facePos = faceLocation(); // the facelocation returns the position of the face in the camera view as a pvector 
  targetX = facePos.x-.5; 
  targetY = facePos.y-.5;
  targetX *= width;
  targetY *= height;
  //float targetZ = facePos.z*5;

  noStroke();
  shapeMode(CENTER);
  
  // LISTEN LETTERs
  int listenFontSize = 150;
  if(facePos.z<=0){
    listenFontSize = listenFontSize/2;
  }
  int listenStrokeWeight = 19;
  int listenAlpha = 255-floor((facePos.z*1.8)*255);
  
   if (listenAlpha > 255){
     listenAlpha = 255;
   }
  
    drawLetter("L", listenFontSize, listenAlpha, height/2, width/10, listenStrokeWeight, true);
    drawLetter("I", listenFontSize, listenAlpha, height/2, width/10*2, listenStrokeWeight, true);
    drawLetter("S", listenFontSize, listenAlpha, height/2, width/10*3, listenStrokeWeight, true);
    drawLetter("T", listenFontSize, listenAlpha, height/2, width/10*4, listenStrokeWeight, true);
    drawLetter("E", listenFontSize, listenAlpha, height/2, width/10*5, listenStrokeWeight, true);
    drawLetter("N", listenFontSize, listenAlpha, height/2, width/10*6, listenStrokeWeight, true);
// make height dependent on the Z value, maybe


  // SILENT LETTERs
    int silentFontSize = 300;
  if(facePos.z<=0){
    silentFontSize = silentFontSize/2;
  }
    int silentStrokeWeight = 19;
    int silentAlpha = 0;
    if(facePos.z > 0.4)
  {
    silentAlpha = floor(((facePos.z-0.4)*2.5)*255);
  }
     
   if (silentAlpha > 255){
     silentAlpha = 255;
   }
     drawLetter("SILENT", silentFontSize, silentAlpha, height/3, width/5, silentStrokeWeight, false);
}

private void drawLetter(String letter, int fontSize, int alpha, int letterY, int letterX, int strokeWeightThiccness, boolean isListen)
{
  pushMatrix();
  font.setSize(fontSize);
translate(letterX, letterY); 

  strokeWeight(strokeWeightThiccness);

  if (letter.length() > 0) {
    // get the points on font outline
    RGroup grp;
    grp = font.toGroup(letter);
    grp = grp.toPolygonGroup();
    RPoint[] pnts = grp.getPoints();

    // ------ svg modules ------
    // dotShape
  if(isListen){  
  imageDisplay(alpha,30, pnts,listenDotColor, dotShape);
  imageDisplay(alpha,18, pnts,listenCrossColor, crossShape);
  }
  else{
  imageDisplay(alpha,30, pnts,silentDotColor, dotShape);
  imageDisplay(alpha,19, pnts,silentCrossColor, crossShape);
  }
  }
  popMatrix();
}

// creates the dot and cross shapes depending on the points generated by the string
 private void imageDisplay(int alpha,
 float diameter,
 RPoint points[],
 color colorHexCode,
 PShape shape
 )
 {    
    fill(colorHexCode, alpha);
    for (int i=0; i < points.length-1; i++ ) {
      // on every third point
      if (i%3 == 0) {
        // rotate the module facing to the next one (i+1)
        pushMatrix();
        float angle = atan2(points[i].y-points[i+1].y, points[i].x-points[i+1].x);
        translate(points[i].x, points[i].y);
        rotate(angle);
        rotate(radians(targetX));
        shape(shape, 0,0, diameter+(targetY/2.5),diameter+(targetY/2.5));
        popMatrix();
      }
    }
 }
  // uncomment for extra information on face orientation
  //PVector orientation = orient(); // the orientation returns the orientation of the face  as a pvector
  //orientation.mult(100);
  //stroke(255, 0, 0);
  //line(width/2, height/2, width/2+orientation.y, height/2+orientation.x);
